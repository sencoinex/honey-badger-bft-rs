use crate::{
    BatchTransactions, DecryptionShareFaultLog, DecryptionShareFaultType, DecryptionShareMessage,
    Epoch, Error, FaultLog, NodeId, NodeMessage, Result, Transaction, ValidatorIndex,
};
use asynchronous_common_subset::AsynchronousCommonSubset;
use core::fmt;
use rand::Rng;
use std::collections::BTreeMap;
use threshold_crypto::{Ciphertext, DecryptionShare, PublicKeyShares, SecretKeyShare};

pub trait HoneyBadger: fmt::Debug {
    type NodeId: NodeId + 'static;
    type ValidatorIndex: ValidatorIndex + 'static;
    type Transaction: Transaction;
    type BatchTransactions: BatchTransactions<Transaction = Self::Transaction>;
    type AsynchronousCommonSubset: AsynchronousCommonSubset<
        NodeId = Self::NodeId,
        ValidatorIndex = Self::ValidatorIndex,
    >;
    type Rng: Rng;

    fn my_id(&self) -> &Self::NodeId;

    fn rng(&mut self) -> &mut Self::Rng;

    fn create_asynchronous_common_subset_instance(
        &mut self,
        epoch: &Epoch,
    ) -> Self::AsynchronousCommonSubset;

    fn next_message(&self) -> NodeMessage<Self::NodeId>;
    fn send_message(&self, target_id: Self::NodeId, message: DecryptionShareMessage<Self::NodeId>);
    fn handle_terminate_message(&self) {
        println!("{:?} has just detected terminate message.", self);
    }

    fn propose(
        &mut self,
        epoch: &Epoch,
        transactions: Self::BatchTransactions,
        validator_indices: BTreeMap<Self::NodeId, Self::ValidatorIndex>,
        secret_key_share: SecretKeyShare,
        public_key_shares: PublicKeyShares,
    ) -> Result<()> {
        let mut fault_logs: Vec<FaultLog<Self::NodeId>> = Vec::new();

        let contribution_bytes = transactions
            .serialize()
            .map_err(|_| Error::BatchTransactionsSerializationError)?;
        let rng = self.rng();
        let ciphertext = public_key_shares
            .public_key()
            .encrypt_with_rng(rng, contribution_bytes);
        let encrypted_contribution_bytes = bincode::serialize(&ciphertext)
            .map_err(|err| Error::EncryptedBatchTransactionsSerializationError { cause: *err })?;
        let mut acs = self.create_asynchronous_common_subset_instance(epoch);
        let acs_result = acs.propose(
            encrypted_contribution_bytes,
            validator_indices.clone(),
            secret_key_share.clone(),
            public_key_shares.clone(),
        )?;

        // { proposer_id: { sender_id: decryption_share } }
        let mut received_decryption_shares: BTreeMap<
            Self::NodeId,
            BTreeMap<Self::NodeId, DecryptionShare>,
        > = BTreeMap::new();
        // { proposer_id: ciphertext }
        let mut received_proposed_ciphertext: BTreeMap<Self::NodeId, Ciphertext> = BTreeMap::new();

        // for each acs output, broadcast its decryption share
        for (proposer_id, rbc_out) in acs_result.as_reliable_broadcast_outputs() {
            if rbc_out.is_none() {
                // skip silent proposer
                continue;
            }
            let rbc_output_bytes = rbc_out.as_ref().unwrap(); // contribution encrypted with public key share by proposer
            let proposed_ciphertext: Ciphertext =
                bincode::deserialize(&rbc_output_bytes).map_err(|err| {
                    Error::EncryptedBatchTransactionsSerializationError { cause: *err }
                })?;
            let decryption_share = secret_key_share.decrypt_share_force(&proposed_ciphertext);
            received_proposed_ciphertext.insert(proposer_id.clone(), proposed_ciphertext);
            // broadcast decryption share
            for (node_id, _index) in &validator_indices {
                if node_id == self.my_id() {
                    let mut init_map = BTreeMap::new();
                    init_map.insert(node_id.clone(), decryption_share.clone());
                    received_decryption_shares.insert(proposer_id.clone(), init_map);
                } else {
                    // send decryption share message to the node
                    self.send_message(
                        node_id.clone(),
                        DecryptionShareMessage::new(
                            proposer_id.clone(),
                            epoch.clone(),
                            decryption_share.clone(),
                        ),
                    );
                }
            }
        }
        // inject fault logs generated by acs instances
        for (_, logs) in acs_result.as_reliable_broadcast_fault_logs() {
            for log in logs {
                fault_logs.push(FaultLog::ReliableBroadcast(log.clone()))
            }
        }
        for (_, logs) in acs_result.as_binary_agreement_fault_logs() {
            for log in logs {
                fault_logs.push(FaultLog::BinaryAgreement(log.clone()))
            }
        }

        // wait for f + 1 decryption share messages from other node
        let max_durable_faulty_size = (validator_indices.len() - 1) / 3;
        loop {
            let node_message = self.next_message();
            match node_message {
                NodeMessage::Terminate => {
                    self.handle_terminate_message();
                    break;
                }
                NodeMessage::BroadcastMessage { sender_id, message } => {
                    if !validator_indices.contains_key(&sender_id) {
                        fault_logs.push(FaultLog::DecryptionShare(DecryptionShareFaultLog {
                            sender_id,
                            message,
                            fault_type: DecryptionShareFaultType::UnknownSender,
                        }));
                        continue;
                    }
                    if !received_proposed_ciphertext.contains_key(&message.proposer_id) {
                        fault_logs.push(FaultLog::DecryptionShare(DecryptionShareFaultLog {
                            sender_id,
                            message,
                            fault_type: DecryptionShareFaultType::InvalidDecryptionShare,
                        }));
                        continue;
                    }
                    let proposed_ciphertext = received_proposed_ciphertext
                        .get(&message.proposer_id)
                        .unwrap();
                    let sender_index = validator_indices.get(&sender_id).unwrap().clone();
                    let public_key_share =
                        public_key_shares.public_key_share(*(sender_index.as_ref()));
                    if !public_key_share
                        .verify_decryption_share(&message.decryption_share, proposed_ciphertext)
                    {
                        fault_logs.push(FaultLog::DecryptionShare(DecryptionShareFaultLog {
                            sender_id,
                            message,
                            fault_type: DecryptionShareFaultType::InvalidDecryptionShare,
                        }));
                        continue;
                    }
                    if received_decryption_shares
                        .get_mut(&message.proposer_id)
                        .unwrap()
                        .insert(sender_id, message.decryption_share)
                        .is_none()
                    {
                        // if newly received, check received enough decryption shares for each proposed ciphertext by acs
                        if received_decryption_shares
                            .iter()
                            .find(|(_proposer_id, decryption_shares)| {
                                decryption_shares.len() <= max_durable_faulty_size
                            })
                            .is_none()
                        {
                            break;
                        }
                    }
                }
            }
        }

        // decode asc outputs by received decryption share messages
        let mut computed_plan_text_contributions: BTreeMap<Self::NodeId, Vec<u8>> = BTreeMap::new();
        for (proposer_id, ciphertext) in received_proposed_ciphertext {
            let decryption_shares = received_decryption_shares.get(&proposer_id).unwrap();
            let shares = decryption_shares.iter().map(|(node_id, decryption_share)| {
                let validator_index = validator_indices.get(node_id).unwrap().clone();
                let index: u64 = validator_index.into();
                (index, decryption_share)
            });
            let plain_text = public_key_shares
                .decrypt(shares, &ciphertext)
                .map_err(|cause| Error::DecryptDecryptionSharesError { cause })?;
            computed_plan_text_contributions.insert(proposer_id, plain_text);
        }

        // TODO combine & sort transactions outputted by the process above -> block!
        todo!()
    }
}
